name: Build Packages

on:
  pull_request:
    branches: [sw]
    types: [closed]
  workflow_call:
    inputs:
      upstream_version:
        description: 'Upstream strongSwan version'
        required: true
        type: string
  workflow_dispatch:
    inputs:
      upstream_version:
        description: 'Upstream version (leave empty for auto-detect)'
        required: false
        type: string

jobs:
  prepare:
    # Run only on merged PRs, workflow_call, or workflow_dispatch
    if: github.event.pull_request.merged == true || github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      rpm_version: ${{ steps.version.outputs.rpm_version }}
      upstream_version: ${{ steps.version.outputs.upstream_version }}
      sw_rev: ${{ steps.version.outputs.sw_rev }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # For merged PR events, checkout the merge commit SHA to ensure it's visible
          ref: ${{ github.event_name == 'pull_request' && github.event.pull_request.merged && github.event.pull_request.merge_commit_sha || 'sw' }}
          fetch-depth: 0
          fetch-tags: true

      - name: Determine version
        id: version
        run: |
          if [ -n "${{ inputs.upstream_version }}" ]; then
            UPSTREAM_VERSION="${{ inputs.upstream_version }}"
          else
            # Get from configure.ac
            UPSTREAM_VERSION=$(grep -m1 'AC_INIT' configure.ac | sed -E 's/.*\[([0-9]+\.[0-9]+\.[0-9]+)\].*/\1/')
          fi

          # Validate UPSTREAM_VERSION is not empty and matches expected format
          if [[ ! "$UPSTREAM_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "ERROR: Invalid UPSTREAM_VERSION: '$UPSTREAM_VERSION'" >&2
            exit 1
          fi

          # Count PR merges after upstream tag to determine SW revision number
          # GitHub adds "(#N)" suffix on squash merge, so we count those
          # This auto-increments: sw.1 -> sw.2 -> sw.3 on each PR merge to sw branch
          # When upstream releases new version, we rebase and SW_REV resets to 1
          # IMPORTANT: Repository MUST use squash merging for PRs to sw branch
          # Manual commits or merge commits won't increment the version number
          # Use git tag -l to check for tags only (git rev-parse would also match branches)
          if git tag -l "${UPSTREAM_VERSION}" | grep -q .; then
            # Tag exists - count squash merged PRs (commits with (#N) suffix)
            # Note: This pattern matches GitHub's squash merge format; manual commits
            # with similar suffixes are unlikely and would only inflate the version
            SW_REV=$(git log "${UPSTREAM_VERSION}..HEAD" --oneline | grep -E -c '\(#[0-9]+\)$' || echo 0)
            # Default to 1 if no PR merges found (minimum is sw.1)
            [ "$SW_REV" -eq 0 ] && SW_REV=1
          else
            # No tag yet - use 1
            SW_REV=1
          fi

          # SW version for DEB: upstream-sw.N (dashes allowed)
          VERSION="${UPSTREAM_VERSION}-sw.${SW_REV}"
          # SW version for RPM: upstream.sw.N (no dashes allowed in Version field)
          RPM_VERSION="${UPSTREAM_VERSION}.sw.${SW_REV}"

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "rpm_version=$RPM_VERSION" >> $GITHUB_OUTPUT
          echo "upstream_version=$UPSTREAM_VERSION" >> $GITHUB_OUTPUT
          echo "sw_rev=$SW_REV" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION / RPM: $RPM_VERSION (upstream $UPSTREAM_VERSION, SW revision $SW_REV)"

  build-deb:
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-24.04
            dist: noble
            libssl: libssl3t64
            libldap: libldap-2.5-0
            arch: amd64
          - os: ubuntu-22.04
            dist: jammy
            libssl: libssl3
            libldap: libldap-2.5-0
            arch: amd64
          - os: ubuntu-22.04
            dist: bookworm
            libssl: libssl3
            libldap: libldap-2.5-0
            arch: amd64

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            autoconf \
            automake \
            libtool \
            pkg-config \
            gettext \
            libgmp-dev \
            libssl-dev \
            libcurl4-openssl-dev \
            libpq-dev \
            libsystemd-dev \
            libcap-dev \
            libpam0g-dev \
            libldap2-dev \
            libsqlite3-dev \
            libgcrypt20-dev \
            libiptc-dev \
            gperf \
            flex \
            bison \
            dpkg-dev \
            fakeroot \
            debhelper \
            gnupg
          # dpkg-sig was removed from Ubuntu Noble (24.04)+; install from Jammy archive as fallback.
          # dpkg-sig is a Perl script with minimal dependencies (perl, libconfig-file-perl).
          if ! sudo apt-get install -y dpkg-sig 2>/dev/null; then
            tmpd="$(mktemp -d)"
            if ! wget -q -P "$tmpd" https://archive.ubuntu.com/ubuntu/pool/universe/d/dpkg-sig/dpkg-sig_0.13.1+nmu4_all.deb; then
              rm -rf "$tmpd"
              echo "Error: failed to download dpkg-sig from Ubuntu archive" >&2
              exit 1
            fi
            sudo apt-get install -y libconfig-file-perl
            sudo dpkg -i "$tmpd"/dpkg-sig_*.deb
            rm -rf "$tmpd"
          fi

      - name: Build strongSwan
        run: |
          UPSTREAM="${{ needs.prepare.outputs.upstream_version }}"

          # Create git tag to satisfy strongSwan version check
          git config user.email "build@sw.foundation"
          git config user.name "Build"
          git tag -f "$UPSTREAM"

          autoreconf -i
          ./configure \
            --prefix=/usr \
            --sysconfdir=/etc \
            --libdir=/usr/lib \
            --libexecdir=/usr/lib \
            --enable-eap-identity \
            --enable-eap-mschapv2 \
            --enable-eap-radius \
            --enable-eap-tls \
            --enable-xauth-eap \
            --enable-vici \
            --enable-swanctl \
            --enable-sql \
            --enable-pgsql \
            --enable-sqlite \
            --enable-systemd \
            --enable-openssl \
            --enable-curl \
            --enable-ldap \
            --enable-pam \
            --enable-gcrypt \
            --enable-farp \
            --enable-dhcp \
            --enable-dhcp-inform \
            --enable-attr-sql \
            --enable-forecast \
            --disable-static

          make -j$(nproc)

      - name: Create DEB packages
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          DIST="${{ matrix.dist }}"
          ARCH="${{ matrix.arch }}"
          LIBSSL="${{ matrix.libssl }}"
          LIBLDAP="${{ matrix.libldap }}"

          # Main package
          PKGDIR="strongswan-sw_${VERSION}_${DIST}_${ARCH}"
          mkdir -p "${PKGDIR}/DEBIAN"

          make DESTDIR="$(pwd)/${PKGDIR}" install

          printf '%s\n' \
            "Package: strongswan-sw" \
            "Version: ${VERSION}" \
            "Section: net" \
            "Priority: optional" \
            "Architecture: ${ARCH}" \
            "Depends: libgmp10, ${LIBSSL}, libcurl4, libsystemd0, libcap2, libpam0g, ${LIBLDAP}, libsqlite3-0, libgcrypt20" \
            "Conflicts: strongswan, strongswan-charon, strongswan-starter" \
            "Provides: strongswan (= ${VERSION})" \
            "Replaces: strongswan, strongswan-charon, strongswan-starter" \
            "Maintainer: Structured World Foundation <dev@sw.foundation>" \
            "Homepage: https://github.com/structured-world/strongswan" \
            "Description: strongSwan IPsec (SW fork)" \
            " strongSwan is a complete IPsec implementation for Linux." \
            " This is the Structured World Foundation fork with socket permissions" \
            " fix (umask 0660 for Unix sockets). Drop-in replacement for system" \
            " strongswan package." \
            > "${PKGDIR}/DEBIAN/control"

          fakeroot dpkg-deb --build "${PKGDIR}"

          # PostgreSQL plugin package
          PGSQL_PKGDIR="strongswan-pgsql_${VERSION}_${DIST}_${ARCH}"
          mkdir -p "${PGSQL_PKGDIR}/DEBIAN"
          mkdir -p "${PGSQL_PKGDIR}/usr/lib/ipsec/plugins"
          mkdir -p "${PGSQL_PKGDIR}/etc/strongswan.d/charon"

          # Copy pgsql plugin to separate package, remove from main package
          PGSQL_SO=$(find "${PKGDIR}" -name "libstrongswan-pgsql.so" -type f | head -1)
          if [ -z "$PGSQL_SO" ]; then
            echo "ERROR: PostgreSQL plugin not found in build output"
            echo "Available plugins:"
            find "${PKGDIR}" -name "*.so" -path "*/plugins/*" | head -20
            exit 1
          fi
          cp -a "$PGSQL_SO" "${PGSQL_PKGDIR}/usr/lib/ipsec/plugins/"
          rm -f "$PGSQL_SO"

          printf '%s\n' \
            "Package: strongswan-pgsql" \
            "Version: ${VERSION}" \
            "Section: net" \
            "Priority: optional" \
            "Architecture: ${ARCH}" \
            "Depends: strongswan (>= 6.0) | strongswan-sw, libpq5" \
            "Maintainer: Structured World Foundation <dev@sw.foundation>" \
            "Homepage: https://github.com/structured-world/strongswan" \
            "Description: PostgreSQL plugin for strongSwan" \
            " PostgreSQL database backend for strongSwan SQL plugin." \
            " Enables storing VPN user credentials and configuration in PostgreSQL." \
            " Works with system strongswan (>= 6.0) or strongswan-sw." \
            > "${PGSQL_PKGDIR}/DEBIAN/control"

          fakeroot dpkg-deb --build "${PGSQL_PKGDIR}"

          # DHCP-Inform plugin package
          DHCP_INFORM_PKGDIR="strongswan-dhcp-inform_${VERSION}_${DIST}_${ARCH}"
          mkdir -p "${DHCP_INFORM_PKGDIR}/DEBIAN"
          mkdir -p "${DHCP_INFORM_PKGDIR}/usr/lib/ipsec/plugins"

          # Copy dhcp-inform plugin to separate package, remove from main package
          DHCP_INFORM_SO=$(find "${PKGDIR}" -name "libstrongswan-dhcp-inform.so" -type f | head -1)
          if [ -n "$DHCP_INFORM_SO" ]; then
            cp -a "$DHCP_INFORM_SO" "${DHCP_INFORM_PKGDIR}/usr/lib/ipsec/plugins/"
            rm -f "$DHCP_INFORM_SO"
            echo "Found dhcp-inform plugin: $DHCP_INFORM_SO"
          else
            echo "WARNING: dhcp-inform plugin not found in build output"
            echo "Available plugins:"
            find "${PKGDIR}" -name "*.so" -path "*/plugins/*" | head -20
          fi

          printf '%s\n' \
            "Package: strongswan-dhcp-inform" \
            "Version: ${VERSION}" \
            "Section: net" \
            "Priority: optional" \
            "Architecture: ${ARCH}" \
            "Depends: strongswan (>= 6.0) | strongswan-sw, strongswan-pgsql" \
            "Maintainer: Structured World Foundation <dev@sw.foundation>" \
            "Homepage: https://github.com/structured-world/strongswan" \
            "Description: DHCP INFORM responder plugin for strongSwan" \
            " Responds to Windows DHCPINFORM requests with split-tunnel routes" \
            " from PostgreSQL database. Delivers routes via DHCP option 121/249." \
            " Works with system strongswan (>= 6.0) or strongswan-sw." \
            > "${DHCP_INFORM_PKGDIR}/DEBIAN/control"

          if [ -n "$DHCP_INFORM_SO" ]; then
            fakeroot dpkg-deb --build "${DHCP_INFORM_PKGDIR}"
          fi

          ls -la *.deb

      - name: Sign DEB packages
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${GPG_PRIVATE_KEY:-}" ]; then
            echo "GPG_PRIVATE_KEY is not set; cannot sign DEB packages." >&2
            exit 1
          fi
          shopt -s nullglob
          deb_files=( *.deb )
          if [ ${#deb_files[@]} -eq 0 ]; then
            echo "Error: No .deb packages found to sign." >&2
            exit 1
          fi

          # keyfile must NOT be local — cleanup_keyfile trap runs at EXIT,
          # after setup_gpg_signing returns, so the variable must persist.
          setup_gpg_signing() {
            local import_output
            keyfile="$(mktemp)"
            cleanup_keyfile() {
              if command -v shred >/dev/null 2>&1; then
                shred -u "$keyfile"
              else
                rm -f "$keyfile"
              fi
            }
            trap cleanup_keyfile EXIT
            chmod 600 "$keyfile"
            printf '%s\n' "$GPG_PRIVATE_KEY" > "$keyfile"
            if ! import_output="$(gpg --batch --with-colons --import-options import-show --import "$keyfile")"; then
              echo "Failed to import GPG private key; aborting package signing." >&2
              exit 1
            fi
            GPG_KEY_FPR="$(printf '%s\n' "$import_output" | awk -F: '/^fpr:/ {print $10; exit}')"
            if [ -z "${GPG_KEY_FPR:-}" ]; then
              echo "Error: Failed to determine GPG key fingerprint for signing." >&2
              exit 1
            fi
            if ! gpg --batch --with-colons --list-keys "$GPG_KEY_FPR" | grep -q '^fpr:'; then
              echo "Expected GPG key fingerprint not found in keyring" >&2
              exit 1
            fi
            # Trust the imported key so dpkg-sig --verify accepts signatures.
            printf '%s:6:\n' "$GPG_KEY_FPR" | gpg --import-ownertrust
          }
          setup_gpg_signing

          dpkg-sig --sign builder -k "$GPG_KEY_FPR" "${deb_files[@]}"
          # dpkg-sig --verify and --list have known BADSIG issues with GnuPG 2.x;
          # verify signatures exist by checking the ar archive for the _gpgbuilder member
          # that dpkg-sig adds during signing. Cryptographic verification happens at
          # APT repo level (Release.gpg/InRelease in publish.yml).
          for deb in "${deb_files[@]}"; do
            if ! ar t "$deb" | grep -q '^_gpgbuilder$'; then
              echo "Error: GPG signature member not found in $deb after signing" >&2
              exit 1
            fi
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deb-${{ matrix.dist }}-${{ matrix.arch }}
          path: "*.deb"
          retention-days: 7

  build-rpm:
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        include:
          - fedora: 39
            container: fedora:39
          - fedora: 40
            container: fedora:40
          - fedora: 41
            container: fedora:41
          - fedora: 42
            container: fedora:42

    runs-on: ubuntu-latest
    container: ${{ matrix.container }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install build dependencies
        run: |
          dnf install -y \
            git \
            gcc \
            make \
            autoconf \
            automake \
            libtool \
            pkgconfig \
            gettext-devel \
            gmp-devel \
            openssl-devel \
            libcurl-devel \
            libpq-devel \
            systemd \
            systemd-devel \
            systemd-rpm-macros \
            libcap-devel \
            pam-devel \
            openldap-devel \
            sqlite-devel \
            libgcrypt-devel \
            iptables-devel \
            gperf \
            flex \
            bison \
            rpm-build \
            rpmdevtools \
            rpm-sign \
            gnupg2

          # Fedora 41+ moved deprecated OpenSSL ENGINE API to separate package
          if [ "${{ matrix.fedora }}" -ge 41 ]; then
            dnf install -y openssl-devel-engine
          fi

      - name: Build RPM and SRPM packages
        env:
          VERSION: ${{ needs.prepare.outputs.rpm_version }}
          UPSTREAM: ${{ needs.prepare.outputs.upstream_version }}
          SW_REV: ${{ needs.prepare.outputs.sw_rev }}
        run: |
          # Configure git for container environment
          # - safe.directory: required for newer git security checks
          # - user.email/name: required if git init is needed
          # - init.defaultBranch: avoid warnings on git init
          git config --global init.defaultBranch main
          git config --global user.email "build@sw.foundation"
          git config --global user.name "Build"
          git config --global --add safe.directory "$(pwd)"

          # Initialize git repo if not present (container checkout may not preserve .git)
          if [ ! -d .git ]; then
            git init
            git add -A
            git commit -m "Imported source"
          fi

          # Create git tag to satisfy strongSwan version check
          git tag -f "$UPSTREAM"

          # Setup rpmbuild structure
          rpmdev-setuptree

          # Create source tarball from git
          # NOTE: This naming must match packaging/rpm/strongswan-sw.spec Source0 and %autosetup
          SOURCE_NAME="strongswan-${UPSTREAM}-sw.${SW_REV}"
          if ! git archive --format=tar.gz --prefix="${SOURCE_NAME}/" HEAD > ~/rpmbuild/SOURCES/${SOURCE_NAME}.tar.gz; then
            echo "ERROR: Failed to create source tarball" >&2
            exit 1
          fi

          # Copy spec file from repository
          cp packaging/rpm/strongswan-sw.spec ~/rpmbuild/SPECS/

          # Build binary RPMs, SRPMs, and debuginfo packages
          rpmbuild -ba ~/rpmbuild/SPECS/strongswan-sw.spec \
            --define "upstream_version ${UPSTREAM}" \
            --define "sw_rev ${SW_REV}" \
            --define "_topdir $HOME/rpmbuild"

          # Copy all packages to workspace
          mkdir -p rpms srpms
          cp ~/rpmbuild/RPMS/*/*.rpm rpms/ 2>/dev/null || true
          cp ~/rpmbuild/SRPMS/*.rpm srpms/ 2>/dev/null || true

          # Verify that packages were actually built
          if ! ls rpms/*.rpm 1>/dev/null 2>&1; then
            echo "ERROR: No RPM packages were built" >&2
            exit 1
          fi
          if ! ls srpms/*.rpm 1>/dev/null 2>&1; then
            echo "ERROR: No SRPM packages were built" >&2
            exit 1
          fi

          echo "=== Binary RPMs ==="
          ls -la rpms/
          echo "=== Source RPMs ==="
          ls -la srpms/

      - name: Sign RPM packages
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${GPG_PRIVATE_KEY:-}" ]; then
            echo "GPG_PRIVATE_KEY is not set; cannot sign RPM packages." >&2
            exit 1
          fi
          # keyfile must NOT be local — cleanup_keyfile trap runs at EXIT,
          # after setup_gpg_signing returns, so the variable must persist.
          setup_gpg_signing() {
            local import_output
            keyfile="$(mktemp)"
            cleanup_keyfile() {
              if command -v shred >/dev/null 2>&1; then
                shred -u "$keyfile"
              else
                rm -f "$keyfile"
              fi
            }
            trap cleanup_keyfile EXIT
            chmod 600 "$keyfile"
            printf '%s\n' "$GPG_PRIVATE_KEY" > "$keyfile"
            if ! import_output="$(gpg --batch --with-colons --import-options import-show --import "$keyfile")"; then
              echo "Failed to import GPG private key; aborting RPM signing." >&2
              exit 1
            fi
            GPG_KEY_FPR="$(printf '%s\n' "$import_output" | awk -F: '/^fpr:/ {print $10; exit}')"
            if [ -z "${GPG_KEY_FPR:-}" ]; then
              echo "Error: Failed to determine GPG key fingerprint for RPM signing." >&2
              exit 1
            fi
            if ! gpg --batch --with-colons --list-keys "$GPG_KEY_FPR" | grep -q '^fpr:'; then
              echo "Expected GPG key fingerprint not found in keyring" >&2
              exit 1
            fi
            # Import public key into RPM database so rpm --checksig trusts our signatures.
            local gpg_pubkey
            gpg_pubkey="$(mktemp)"
            if ! gpg --batch --armor --export "$GPG_KEY_FPR" > "$gpg_pubkey" || [ ! -s "$gpg_pubkey" ]; then
              rm -f "$gpg_pubkey"
              echo "Error: failed to export GPG public key for RPM database import" >&2
              exit 1
            fi
            rpm --import "$gpg_pubkey"
            rm -f "$gpg_pubkey"
          }
          setup_gpg_signing

          rm -f ~/.rpmmacros
          printf '%s\n' \
            '%_signature gpg' \
            "%_gpg_name ${GPG_KEY_FPR}" \
            '%_gpg_digest_algo sha256' \
            > ~/.rpmmacros

          shopt -s nullglob
          rpm_files=(rpms/*.rpm)
          srpm_files=(srpms/*.rpm)
          if [ ${#rpm_files[@]} -eq 0 ] && [ ${#srpm_files[@]} -eq 0 ]; then
            echo "Error: No RPM packages found in rpms/ or srpms/; cannot sign." >&2
            exit 1
          fi
          if [ ${#rpm_files[@]} -gt 0 ]; then
            rpmsign --addsign "${rpm_files[@]}"
          fi
          if [ ${#srpm_files[@]} -gt 0 ]; then
            rpmsign --addsign "${srpm_files[@]}"
          fi
          if [ ${#rpm_files[@]} -gt 0 ] && ! rpm --checksig "${rpm_files[@]}"; then
            echo "Error: Failed to verify RPM signatures" >&2
            exit 1
          fi
          if [ ${#srpm_files[@]} -gt 0 ] && ! rpm --checksig "${srpm_files[@]}"; then
            echo "Error: Failed to verify SRPM signatures" >&2
            exit 1
          fi

      - name: Upload RPM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rpm-fc${{ matrix.fedora }}
          path: "rpms/*.rpm"
          retention-days: 7

      # Upload SRPM only from fc42 job to avoid duplicates (SRPMs are identical across distros)
      # If fc42 build fails, SRPMs won't be uploaded - this is acceptable as binary
      # RPMs are the primary deliverable and SRPMs can be regenerated from git
      - name: Upload SRPM artifacts
        if: matrix.fedora == 42
        uses: actions/upload-artifact@v4
        with:
          name: srpm
          path: "srpms/*.rpm"
          retention-days: 7

  trigger-repo:
    needs: [prepare, build-deb, build-rpm]
    runs-on: ubuntu-latest
    outputs:
      publish_run_id: ${{ steps.wait-publish.outputs.run_id }}

    steps:
      - name: Generate release bot token
        uses: actions/create-github-app-token@v2
        id: app-token
        with:
          app-id: ${{ secrets.RELEASER_APP_ID }}
          private-key: ${{ secrets.RELEASER_APP_PRIVATE_KEY }}
          owner: structured-world
          repositories: repo
          permission-actions: write
          permission-contents: read

      - name: Trigger repo publish workflow
        id: trigger-repo
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          # publish.yml expects workflow_dispatch input: strongswan_run_id
          if ! gh workflow run publish.yml \
            -R structured-world/repo \
            -f "strongswan_run_id=${{ github.run_id }}"; then
            echo "Error: failed to trigger publish.yml in structured-world/repo" >&2
            exit 1
          fi

      - name: Wait for publish workflow to start
        id: wait-publish
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          # Keep these in sync with structured-world/repo/.github/workflows/publish.yml
          PUBLISH_WORKFLOW_NAME="Publish Repo"
          RUN_MATCH="Publish Repo (strongswan ${{ github.run_id }})"
          START_TIMEOUT_SECONDS=600 # 10 minutes
          START_POLL_INTERVAL=10
          START_MAX_ATTEMPTS=$((START_TIMEOUT_SECONDS / START_POLL_INTERVAL))
          # Workflow name must match repo workflow name exactly.
          for ((i=1; i<=START_MAX_ATTEMPTS; i++)); do
            echo "Waiting for Publish Repo to start (attempt ${i}/${START_MAX_ATTEMPTS})..."
            RUN_IDS=$(gh run list -R structured-world/repo -w "$PUBLISH_WORKFLOW_NAME" --json databaseId,createdAt,event,displayTitle \
              --jq "[.[] | select(.event == \"workflow_dispatch\" and .displayTitle == \"${RUN_MATCH}\") | {id: .databaseId, createdAt: .createdAt}] | sort_by(.createdAt) | reverse | .[0].id // empty") || {
              echo "Error: gh run list failed while waiting for Publish Repo workflow" >&2
              exit 1
            }
            RUN_ID=$(printf '%s\n' "$RUN_IDS")
            if [ -n "$RUN_ID" ]; then
              echo "run_id=$RUN_ID" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            sleep "$START_POLL_INTERVAL"
          done
          echo "Error: timed out waiting for Publish Repo to start after ${START_TIMEOUT_SECONDS} seconds" >&2
          exit 1

  # Create GitHub Release in the fork (no artifacts, just links to package repo)
  release:
    needs: [prepare, trigger-repo]
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Generate release bot token
        uses: actions/create-github-app-token@v2
        id: app-token
        with:
          app-id: ${{ secrets.RELEASER_APP_ID }}
          private-key: ${{ secrets.RELEASER_APP_PRIVATE_KEY }}
          owner: structured-world
          repositories: strongswan,repo
          permission-contents: write
          permission-actions: read

      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token }}

      - name: Wait for publish workflow to complete
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          RUN_ID="${{ needs.trigger-repo.outputs.publish_run_id }}"
          if [ -z "$RUN_ID" ]; then
            echo "Error: missing publish run id" >&2
            exit 1
          fi
          COMPLETE_TIMEOUT_SECONDS=1200 # 20 minutes
          COMPLETE_POLL_INTERVAL=10
          COMPLETE_MAX_ATTEMPTS=$((COMPLETE_TIMEOUT_SECONDS / COMPLETE_POLL_INTERVAL))
          for ((i=1; i<=COMPLETE_MAX_ATTEMPTS; i++)); do
            if ! STATUS=$(gh run view -R structured-world/repo "$RUN_ID" --json status,conclusion --jq '(.status // "unknown") + ":" + (.conclusion // "none")'); then
              echo "Error: failed to query status for publish workflow run $RUN_ID" >&2
              exit 1
            fi
            if [ -z "$STATUS" ]; then
              echo "Error: empty status returned for publish workflow run $RUN_ID" >&2
              exit 1
            fi
            case "$STATUS" in
              completed:success)
                echo "Publish workflow completed successfully"
                exit 0
                ;;
              completed:*)
                echo "Publish workflow failed with status $STATUS" >&2
                exit 1
                ;;
              *)
                echo "Waiting for publish workflow to complete (attempt ${i}/${COMPLETE_MAX_ATTEMPTS}, status: $STATUS)"
                sleep "$COMPLETE_POLL_INTERVAL"
                ;;
            esac
          done
          echo "Error: timed out waiting for Publish Repo completion after ${COMPLETE_TIMEOUT_SECONDS} seconds" >&2
          exit 1

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          UPSTREAM="${{ needs.prepare.outputs.upstream_version }}"

          # Create release notes (using {{PLACEHOLDER}} pattern for clarity)
          printf '%s\n' \
            '## strongSwan SW {{VERSION}}' \
            '' \
            'Based on upstream strongSwan {{UPSTREAM}} with the following SW fork modifications:' \
            '' \
            '### Changes' \
            '' \
            '- **PostgreSQL database plugin** - SQL-based authentication and authorization' \
            '- **Unix socket permissions fix** - Proper umask (0660) for VICI socket' \
            '- **DHCP-inform plugin** - Windows split-tunnel routes via DHCP option 121/249' \
            '' \
            '### Installation' \
            '' \
            'See the [website](https://structured-world.github.io/strongswan/) for installation instructions.' \
            > release-notes.md

          # Substitute placeholders in release notes
          sed -i "s/{{VERSION}}/${VERSION}/g" release-notes.md
          sed -i "s/{{UPSTREAM}}/${UPSTREAM}/g" release-notes.md

          # Create or update GitHub release (idempotent)
          if gh release view "${VERSION}" >/dev/null 2>&1; then
            echo "Release ${VERSION} exists, updating..."
            gh release edit "${VERSION}" \
              --title "strongSwan SW ${VERSION}" \
              --notes-file release-notes.md
          else
            echo "Creating release ${VERSION}..."
            gh release create "${VERSION}" \
              --title "strongSwan SW ${VERSION}" \
              --notes-file release-notes.md \
              --target sw
          fi
